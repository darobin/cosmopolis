var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/nanoid-dictionary/lowercase.js
var require_lowercase = __commonJS({
  "node_modules/nanoid-dictionary/lowercase.js"(exports, module) {
    module.exports = "abcdefghijklmnopqrstuvwxyz";
  }
});

// ui/lib/keyboard.js
function makeKeyDownMatcher(sc, cb) {
  return makeKeyMatcher("keydown", sc, cb);
}
function makeKeyMatcher(type, sc, cb) {
  const parts = sc.split(/[+-]/);
  const key = parts.pop().toLowerCase();
  const modifiers = {
    shiftKey: false,
    ctrlKey: false,
    metaKey: false,
    altKey: false
  };
  parts.forEach((p2) => {
    p2 = p2.toLowerCase();
    if (p2 === "cmd")
      p2 = "meta";
    const mod = `${p2}Key`;
    if (typeof modifiers[mod] !== "boolean")
      console.warn(`Unknown command modifier ${p2}.`);
    modifiers[mod] = true;
  });
  return (evt) => {
    if (type !== evt.type)
      return;
    if (key.toLowerCase() !== evt.key)
      return;
    let badMod = false;
    Object.keys(modifiers).forEach((mod) => {
      if (evt[mod] !== modifiers[mod])
        badMod = true;
    });
    if (badMod)
      return;
    cb();
  };
}

// ui/lib/debug.js
function registerReload() {
  window.addEventListener("keydown", makeKeyDownMatcher("cmd+R", reload));
  window.addEventListener("keydown", makeKeyDownMatcher("ctrl+R", reload));
}
function reload() {
  console.warn("RELOAD");
  window.location.reload();
}

// ui/lib/tauri.js
var { invoke, convertFileSrc, transformCallback } = window.__TAURI__.tauri;
var { appWindow } = window.__TAURI__.window;

// node_modules/nanoid/index.browser.js
var random = (bytes) => crypto.getRandomValues(new Uint8Array(bytes));
var customRandom = (alphabet, defaultSize, getRandom) => {
  let mask = (2 << Math.log(alphabet.length - 1) / Math.LN2) - 1;
  let step = -~(1.6 * mask * defaultSize / alphabet.length);
  return (size = defaultSize) => {
    let id = "";
    while (true) {
      let bytes = getRandom(step);
      let j = step;
      while (j--) {
        id += alphabet[bytes[j] & mask] || "";
        if (id.length === size)
          return id;
      }
    }
  };
};
var customAlphabet = (alphabet, size = 21) => customRandom(alphabet, size, random);

// ui/lib/contexts.js
var import_lowercase = __toESM(require_lowercase(), 1);

// ui/lib/tauri/store.js
var Store = class {
  constructor(path) {
    this.path = path;
  }
  /**
   * Inserts a key-value pair into the store.
   *
   * @param key
   * @param value
   * @returns
   */
  async set(key, value) {
    return await invoke("plugin:store|set", {
      path: this.path,
      key,
      value
    });
  }
  /**
   * Returns the value for the given `key` or `null` the key does not exist.
   *
   * @param key
   * @returns
   */
  async get(key) {
    return await invoke("plugin:store|get", {
      path: this.path,
      key
    });
  }
  /**
   * Returns `true` if the given `key` exists in the store.
   *
   * @param key
   * @returns
   */
  async has(key) {
    return await invoke("plugin:store|has", {
      path: this.path,
      key
    });
  }
  /**
   * Removes a key-value pair from the store.
   *
   * @param key
   * @returns
   */
  async delete(key) {
    return await invoke("plugin:store|delete", {
      path: this.path,
      key
    });
  }
  /**
   * Clears the store, removing all key-value pairs.
   *
   * Note: To clear the storage and reset it to it's `default` value, use `reset` instead.
   * @returns
   */
  async clear() {
    return await invoke("plugin:store|clear", {
      path: this.path
    });
  }
  /**
   * Resets the store to it's `default` value.
   *
   * If no default value has been set, this method behaves identical to `clear`.
   * @returns
   */
  async reset() {
    return await invoke("plugin:store|reset", {
      path: this.path
    });
  }
  /**
   * Returns a list of all key in the store.
   *
   * @returns
   */
  async keys() {
    return await invoke("plugin:store|keys", {
      path: this.path
    });
  }
  /**
   * Returns a list of all values in the store.
   *
   * @returns
   */
  async values() {
    return await invoke("plugin:store|values", {
      path: this.path
    });
  }
  /**
   * Returns a list of all entries in the store.
   *
   * @returns
   */
  async entries() {
    return await invoke("plugin:store|entries", {
      path: this.path
    });
  }
  /**
   * Returns the number of key-value pairs in the store.
   *
   * @returns
   */
  async length() {
    return await invoke("plugin:store|length", {
      path: this.path
    });
  }
  /**
   * Attempts to load the on-disk state at the stores `path` into memory.
   *
   * This method is useful if the on-disk state was edited by the user and you want to synchronize the changes.
   *
   * Note: This method does not emit change events.
   * @returns
   */
  async load() {
    return await invoke("plugin:store|load", {
      path: this.path
    });
  }
  /**
   * Saves the store to disk at the stores `path`.
   *
   * As the store is only persisted to disk before the apps exit, changes might be lost in a crash.
   * This method lets you persist the store to disk whenever you deem necessary.
   * @returns
   */
  async save() {
    return await invoke("plugin:store|save", {
      path: this.path
    });
  }
  /**
   * Listen to changes on a store key.
   * @param key
   * @param cb
   * @returns A promise resolving to a function to unlisten to the event.
   */
  async onKeyChange(key, cb) {
    return await appWindow.listen("store://change", (event) => {
      if (event.payload.path === this.path && event.payload.key === key) {
        cb(event.payload.value);
      }
    });
  }
  /**
   * Listen to changes on the store.
   * @param cb
   * @returns A promise resolving to a function to unlisten to the event.
   */
  async onChange(cb) {
    return await appWindow.listen("store://change", (event) => {
      if (event.payload.path === this.path) {
        cb(event.payload.key, event.payload.value);
      }
    });
  }
};

// ui/lib/contexts.js
var CTX_LIST = "$ctx-list";
var nanoid = customAlphabet(import_lowercase.default);
var store = new Store("contexts.store");
var contexts = await store.get(CTX_LIST);
if (!contexts) {
  contexts = [];
  await store.set(CTX_LIST, []);
}

// ui/cosmopolis.js
appWindow.maximize();
registerReload();
var h1 = document.querySelector("h1");
h1.style.color = "orange";
var p = document.createElement("p");
p.textContent = await invoke("welcome", { name: "cosmopolis" });
h1.after(p);
